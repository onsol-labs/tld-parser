/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
    assertAccountExists,
    assertAccountsExist,
    combineCodec,
    decodeAccount,
    fetchEncodedAccount,
    fetchEncodedAccounts,
    fixDecoderSize,
    fixEncoderSize,
    getAddressDecoder,
    getAddressEncoder,
    getBytesDecoder,
    getBytesEncoder,
    getStructDecoder,
    getStructEncoder,
    getU8Decoder,
    getU8Encoder,
    transformEncoder,
    type Account,
    type Address,
    type Codec,
    type Decoder,
    type EncodedAccount,
    type Encoder,
    type FetchAccountConfig,
    type FetchAccountsConfig,
    type MaybeAccount,
    type MaybeEncodedAccount,
    type ReadonlyUint8Array,
  } from '@solana/kit';
  import {
    getMintStandardDecoder,
    getMintStandardEncoder,
    getTagDecoder,
    getTagEncoder,
    type MintStandard,
    type MintStandardArgs,
    type Tag,
    type TagArgs,
  } from '../types';
  
  export const NFT_RECORD_DISCRIMINATOR = new Uint8Array([
    174, 190, 114, 100, 177, 14, 90, 254,
  ]);
  
  export function getNftRecordDiscriminatorBytes() {
    return fixEncoderSize(getBytesEncoder(), 8).encode(NFT_RECORD_DISCRIMINATOR);
  }
  
  export type NftRecord = {
    discriminator: ReadonlyUint8Array;
    /** Tag */
    tag: Tag;
    /** Nonce == bump */
    bump: number;
    /** Name account of the record */
    nameAccount: Address;
    /** Record owner */
    owner: Address;
    /** NFT mint */
    nftMintAccount: Address;
    /** tld house */
    tldHouse: Address;
    /** mint standard for parsing nft. */
    mintStandard: MintStandard;
  };
  
  export type NftRecordArgs = {
    /** Tag */
    tag: TagArgs;
    /** Nonce == bump */
    bump: number;
    /** Name account of the record */
    nameAccount: Address;
    /** Record owner */
    owner: Address;
    /** NFT mint */
    nftMintAccount: Address;
    /** tld house */
    tldHouse: Address;
    /** mint standard for parsing nft. */
    mintStandard: MintStandardArgs;
  };
  
  export function getNftRecordEncoder(): Encoder<NftRecordArgs> {
    return transformEncoder(
      getStructEncoder([
        ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
        ['tag', getTagEncoder()],
        ['bump', getU8Encoder()],
        ['nameAccount', getAddressEncoder()],
        ['owner', getAddressEncoder()],
        ['nftMintAccount', getAddressEncoder()],
        ['tldHouse', getAddressEncoder()],
        ['mintStandard', getMintStandardEncoder()],
      ]),
      (value) => ({ ...value, discriminator: NFT_RECORD_DISCRIMINATOR })
    );
  }
  
  export function getNftRecordDecoder(): Decoder<NftRecord> {
    return getStructDecoder([
      ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
      ['tag', getTagDecoder()],
      ['bump', getU8Decoder()],
      ['nameAccount', getAddressDecoder()],
      ['owner', getAddressDecoder()],
      ['nftMintAccount', getAddressDecoder()],
      ['tldHouse', getAddressDecoder()],
      ['mintStandard', getMintStandardDecoder()],
    ]);
  }
  
  export function getNftRecordCodec(): Codec<NftRecordArgs, NftRecord> {
    return combineCodec(getNftRecordEncoder(), getNftRecordDecoder());
  }
  
  export function decodeNftRecord<TAddress extends string = string>(
    encodedAccount: EncodedAccount<TAddress>
  ): Account<NftRecord, TAddress>;
  export function decodeNftRecord<TAddress extends string = string>(
    encodedAccount: MaybeEncodedAccount<TAddress>
  ): MaybeAccount<NftRecord, TAddress>;
  export function decodeNftRecord<TAddress extends string = string>(
    encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
  ): Account<NftRecord, TAddress> | MaybeAccount<NftRecord, TAddress> {
    return decodeAccount(
      encodedAccount as MaybeEncodedAccount<TAddress>,
      getNftRecordDecoder()
    );
  }
  
  export async function fetchNftRecord<TAddress extends string = string>(
    rpc: Parameters<typeof fetchEncodedAccount>[0],
    address: Address<TAddress>,
    config?: FetchAccountConfig
  ): Promise<Account<NftRecord, TAddress>> {
    const maybeAccount = await fetchMaybeNftRecord(rpc, address, config);
    assertAccountExists(maybeAccount);
    return maybeAccount;
  }
  
  export async function fetchMaybeNftRecord<TAddress extends string = string>(
    rpc: Parameters<typeof fetchEncodedAccount>[0],
    address: Address<TAddress>,
    config?: FetchAccountConfig
  ): Promise<MaybeAccount<NftRecord, TAddress>> {
    const maybeAccount = await fetchEncodedAccount(rpc, address, config);
    return decodeNftRecord(maybeAccount);
  }
  
  export async function fetchAllNftRecord(
    rpc: Parameters<typeof fetchEncodedAccounts>[0],
    addresses: Array<Address>,
    config?: FetchAccountsConfig
  ): Promise<Account<NftRecord>[]> {
    const maybeAccounts = await fetchAllMaybeNftRecord(rpc, addresses, config);
    assertAccountsExist(maybeAccounts);
    return maybeAccounts;
  }
  
  export async function fetchAllMaybeNftRecord(
    rpc: Parameters<typeof fetchEncodedAccounts>[0],
    addresses: Array<Address>,
    config?: FetchAccountsConfig
  ): Promise<MaybeAccount<NftRecord>[]> {
    const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
    return maybeAccounts.map((maybeAccount) => decodeNftRecord(maybeAccount));
  }
  
  export function getNftRecordSize(): number {
    return 139;
  }
  